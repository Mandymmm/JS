#第二周第五天
[toc]
##正则

> 正则很重要


###正则是什么？如何学习

- `正则`：就是由相关**‘元字符**’和**‘修饰符’**组成的一个规则，用来**匹配、验证**或者**捕获字符串中某些内容**的规则
	- 正则**仅仅是**用来处理字符串的

- 如何学习----- 要掌握：
	- 元字符
	- 修饰符
	- 能够编写常用的正则
	- 正则的验证
	- 正则的捕获
	- 正则的一些小实战以及一些常规方法的封装：myQueryURLParamter、myTrim、myFormatTime...


####回顾字符串中常用的方法
- **charAt / charCodeAt** ：根据索引获取指定位置的字符 / 字符的Unicode编码值
	- **String.fromCharCode(Unicode编码值)** ------ 通过指定的编码获取指定的字符[是String类上的一个方法]
- **substr(n,m)**：从索引n开始截取m个字符(m不写 截取到末尾) 【n和m不支持负数】
- **substring(n,m)**：从索引n开始找到索引为m处(不包含m) 【n和m不支持负数】
- **slice(n,m)**：和substring一样，只是 【**支持负数索引** --- 总长度+负数索引=查找的索引位置】
- **indexOf / lastIndexOf**：找到字符在字符串中第一次 / 最后一次出现位置的索引值 【字符串里的这两个方法是兼容的，数组里的不兼容】
	- 如果没有这个字符返回的是-1 ----- 这个机制可以判断当前的字符串当中是否包含这个字符
- **search**：和indexOf相同，都是获取字符出现位置的索引，只是search**可以支持正则**
- **toUpperCase / toLowerCase**：把一个字符串中的所有字符转化成大写 / 小写
- **split**：按照指定的分隔符，把一个字符串拆分成数组中的每一项 【**可以支持正则**】
- **replace**：把字符串中的原有字符进行替换，在不使用正则的情况下，执行一次replace，只能替换一次，这个方法**可以支持正则**
- **match**：根据正则，匹配到所有符合规则的结果，最后以一个数组来存储
- **localeCompare**：两个字符串之间的比较，按照每一个字符的Unicode编码值一个个比较
- **trim / trimLeft / trimRight**：去除字符串的首尾所有空格 / 去除首所有空格 / 去除尾所有空格 ，但是字符中间的空格不能去除 ------ **不兼容**
- ...... 

###正则的元字符

只要在**两个斜杠//之间包起来**的，都是正则的元字符

####特殊元字符

- `\` ----- 转义字符(有意义的字符和无意义的字符之间的转换)
- `.`  ----- 除了 \n 以外的任意字符(属于无意义字符)
	- `\n` ----- 换行
	- 例如：/./ --->一个点表示匹配字符串中出现的第一个非换行符字符
- `^` ----- (caret符)以xxx开始，只匹配字符串的开头
- `$` ----- 以xxx结束，只匹配字符串的结尾
```
    var str='huge';
    var reg1=/^u/;
    console.log(reg1.exec(str));//->null 字符串的开头不是u这个字符 匹配失败

    var reg2=/^h/;
    console.log(reg2.exec(str));//->["h", index: 0, input: "huge"]

    var reg3=/g$/;
    console.log(reg3.exec(str));//->null 没能在字符串的结尾找到g这个字符 匹配成功

    var reg4=/e$/;
    console.log(reg4.exec(str));//->["e", index: 3, input: "huge"]

```
- `\d` ----- 匹配0-9之间的任意数字 (即代表0-9之间的任意数字)，等价于[0-9]
- `\D` ----- 除了0-9之间数字的任意字符
- `\b` ----- 匹配一个单词边界(也就是指单词和空格间的位置或一个字符串开头或结尾的边界)
	- 例如：“er\b” ---> 可以匹配’never‘中的er，但是不能匹配’verb‘中的er
- `\w` ----- 匹配数字、字母、下划线中的任意字符，等价于[a-zA-Z0-9_]
- `\s` ----- 匹配一个空白字符(空格、制表符(tab键)、换页符)
	- `\s+` ----- 匹配一个到多个空白字符
- `[xyz]` ----- x或者y或者z三者中的任意一个
	- 例如：[abcd] --- 四个字母中的任意一个
- `[^xyz]` ----- 除了xyz三个以外的任意字符
- `[a-z]` ----- 匹配指定范围(a-z)中任意字符
	- 例如： [A-Z] 、[0-9] (中括号里这样写数字只能是0-9)
- `[^a-z]` ----- 匹配不在a-z范围内的任意字符
- `x|y` ----- 匹配x或者y中的任意一个
- `()` ----- 分组
- `?:` ----- 只匹配不捕获
- `?=` ----- 正向预查(预先判断为某个值，匹配条件为：带xxx的，但是匹配结果不要xxx)
	- 例如：
		- /\b(\w)+(?=ing\b)/g ---> 匹配带ing的单词，但是不要ing 
		-/ Windows(?=95|98|2000)/ --->匹配带95|98|2000，但是匹配结果只是Windows 不要95|98|2000，即能匹配‘Windows 2000’中的‘Windows‘，但是不能匹配’Windows 3.1‘中的’Windows‘
- `?!` ----- 负向预查**(条件不能是xxx的**) 【写在开头】
	- 例如：
		- / Windows(?!95|98|2000)/ --->能匹配‘Windows 3.1’中的‘Windows‘，但是不能匹配''Windows 2000'中的’Windows‘

【**两个预查**也起到了**只匹配不捕获**的作用】
- `|` ----- 正则表达式中的或 
	- 把**“|”左右两边**的一到多个字符**当成一个整体对待**
		- 例如：reg=/^z|o.+/; 意思是匹配开头的z或者匹配一个o后边连续出现一到多个任意字符，而并非表示已z或o凯瑞 => 如果是表示已z或o开头应该写成：reg=/^(z|o).+/
- ......

```
    var str1='hahbeq';
    var reg = /[abc]/;
    console.log(str1.match(reg));//->["a", index: 1, input: "hahbeq"] 只匹配到了一个a 而b并没有输出


    var str1='hahbeq';
    var reg = /[^abc]/;
    console.log(str1.match(reg));//->["h", index: 0, input: "hahaeq"] 只匹配到第一个h
```

####量词元字符

- `*`  ----- 出现零次或者多次
	- 等价于 {0,}
- `?`  ----- 出现零次或者一次
	- 等价于{0,1}
- `+`  ----- 出现一次或者多次
	- 等价于 {1,}
- `{n}` ----- 连续出现n次
- `{n,}` ----- 连续出现n到多次 ---> (也就是最少连续出现n次)
- `{n,m}` ----- 连续出现n到m次(n<=m)

####普通元字符

代表本身意思的元字符，都是普通元字符

###正则的修饰符(i、m、g)
- `i` ----- ignoreCase  忽略大小写(不管大小写都可以找)
- `m` ------ multiline  匹配换行(如果字符串中换行了依然可以查找)
- `g` ------ global  全局匹配 (在整个字符串中查找)

###()分组的作用
1. 可以**改变**正则处理时候的**优先级**
	- 例如： (x|y)
2. **分组捕获**：分组其实可以理解为一个**大正则**中分出的一个**小正则**，在正则捕获的时候，我们不仅仅可以把大正则匹配的结果捕获到，也可以把小分组匹配的结果捕获到
3. **分组引用**：出现和前面一模一样的结果
	- `\num` ---> 表示在该位置出现和第num个分组一模一样的(内容都一模一样的)，但是需要保证当前引用的分组能够捕获到(也就是分组里不能加?:  、 ?= 、?!)
		- 比如： 
			- `\1 `--->表示在\1出现的位置有和第一个小分组一模一样的部分
			- `\2 `--->表示在\2出现的位置有和第二个小分组一模一样的部分
```
改变优先级:

	var reg=/^18|29$/;// 这样写的话，当前的正则匹配的优先级顺序特别的乱： 18、29、189、182、129、829、1829...这些都符合，而不是我们想要的18或者29
    // ===>解决：
    var reg=/^(18|29)$/;//现在只有18和29符合了
```
```
分组引用：

	var reg=/^[a-zA-Z]([a-zA-Z])\1[a-zA-Z]$/;//-> \1 表示在该位置出现和第一个分组一模一样的(内容都一模一样的)，但是需要保证当前引用的分组能够捕获到(也就是不能加 ?:、 ?=、 ?! )
    //AXXB : 中间两个一样 例如：look、good...
    var reg=/^[a-zA-Z]([a-zA-Z])[a-zA-Z]\1$/;// -> AXBX

    var reg=/^([a-z])([a-z])\2\1&/;// -> ABBA  \2则表示在该位置出现和第二个分组一模一样的部分
```

###如何区分是第几个分组：
按照**小括号的左半部分从左到右数**即可，不**分层级**，但是数的过程中**要跳过 '?:'、'?='、'?!'** --- 小括号里面有这三个就不数它了，忽略有这三个的小括号

###[]中括号的一些细节问题：
1. 中括号中出现的元字符大部分都是**代表的本身含义**
	- 例如：
		- [+-]中的+就代表加号，而不是量词元字符
		- [.]中的点就是一个点的意思，而不是非换行符的任意字符了
2. 中括号里面**不能识别两位数字**
	- 例如：
		- **/^[18-65]$/** ---> 它不是表示18-65之间，而是**代表1或者8-6或者5中间的一个**(但是这里不能8-6这样写范围，所以正则会报错)

###正则的方法
- `test()`  ----- **验证**某一个字符串是否符合某一个规则
	- 是RegExp的一个方法，以字符串为参数
	- 经常应用于 **表单验证** --- 验证用户输入的内容是否符合既定格式
```
    var reg=/\d+/;//->只要包含连续出现的一个到多个数字 这个规则就可以匹配成功
    console.log(reg.test(str));//->true

    reg=/^\d+$/;//以数字开头 以数字结尾 中间只能是数字 => 只能是纯数字 才符合这个规则
    console.log(reg.test(str));//->false

```
- `exec()` ----- **捕获**字符串中符合规则的字符
	- 是RegExp的一个方法，以字符串为参数
	- **返回结果**是一个**数组**(是Array的实例)
		- 第一项是正则捕获的内容
		- 如果有小分组第二项往后依次是捕获到的小分组的内容
		- 倒数第二项是 index键值对 --- 表示捕获开始的索引
		- 最后一项是 input键值对 --- 是原始的字符串
	- **执行一次exec只能捕获一次**，需要捕获多个的话，也需要执行多次，但是**如果正则表达式不进行处理，不管执行多少次，捕获到的永远是第一个** ==> 正则的`懒惰性`

	- **exec每一次捕获**的时候不仅可以把大**正则匹配的结果**捕获到，也可以获取**小分组捕获的结果**，**但是**不能直接捕获多次
	- 因为执行一次exec只能捕获一次，**具体需要捕获多少次**，又可能**不太清楚** ，所以需要利用**while循环来捕获**
	

**举例：**
(1). 返回值是一个数组
```
    var str='zhufeng2017peixun2018';
    var reg=/\d+/;
    console.log(reg.exec(str));//->["2017", index: 7, input: "zhufeng2017peixun2018"]
    //通过exec()执行，获取的结果是一个数组(是Array的实例)，第一项是正则捕获的内容，index是捕获开始的索引，input是原始的字符串
```
(2). 不管执行多少次，捕获到的永远是第一个 ==> 正则的懒惰性 ==> 正则表达式加g解决
```
    // 执行一次exec() 只能捕获一次 ，需要捕获多个的话，也需要执行多次
    console.log(reg.lastIndex);//->0
    console.log(reg.exec(str));//->['2017'...]
    console.log(reg.lastIndex);//->0
    reg.lastIndex=11;
    console.log(reg.lastIndex);//->11
    console.log(reg.exec(str));//->['2017'...]
    //不管执行多少次，捕获到的永远是第一个 ==> 正则的**懒惰性**  是因为正则里面有一个属性 lastIndex

    //-> reg.lastIndex ：下一次正则捕获的起始索引位置(也就是下一次捕获的时候是从哪开始找的)，第一次捕获的时候值为0，在正则不进行任何处理的情况下，下一次捕获之前这个值依然为0，所以会重复捕获第一个内容
    //->而且即使我们手动把lastIndex值改了，也没有作用，解决懒惰性只能有一种办法：给正则加全局修饰符g(global)

    //->加上g就可以解决了
    var str='zhufeng2017peixun2018';
    var reg=/\d+/g;
    console.log(reg.exec(str));//->['2017'...]
    console.log(reg.lastIndex);//->11
    console.log(reg.exec(str));//->['2018'...]
    console.log(reg.lastIndex);//->21
    console.log(reg.exec(str));//->null

```
(3). 但是具体要捕获多少次，可能不太清楚 ==> 循环捕获
```
	var str='zhufeng2017peixun2018yangfan2019qihang2020zhidao9999';
    var reg=/\d+/g;
	var ary=[];
    var result=reg.exec(str);
    while (result){ //只要result不为null就一直执行循环
        ary.push(result[0]);
        result=reg.exec(str);
    }
    console.log(ary);//->["2017", "2018", "2019", "2020", "9999"]
```


- `match()` ----- 字符串里的方法，配合正则使用可以实现执行一次捕获多次的效果
	- 而**使用match()**来实现捕获的时候
		- 如果进行捕获的字符串**需要捕获`多次`**的话，**只能捕获到大正则的**，小分组的是不能捕获的
		- 如果进行捕获的字符串**`只`需要捕获`一次`**的话，**也可以把小分组的内容捕获到**
```
	var str='zhufeng2017peixun2018yangfan2019qihang2020zhidao9999';
    var reg=/\d+/g;
    console.log(str.match(reg));//->["2017", "2018", "2019", "2020", "9999"]
```

```
//需要捕获多次：
	var str = 'zhufeng2017peixun2018yangfan2019qihang2020zhidao9999';
	var reg = /(\d)+/g;
	console.log(str.match(reg));//->["2017", "2018", "2019", "2020", "9999"]

//只需要捕获一次：
	var str1='zhufeng2017';
	var reg1 = /(\d)+/;//->只捕获一次 不用加g
console.log(str1.match(reg1));//->["2017", "7", index: 7, input: "zhufeng2017"]
```

【**使用match()**方法实现多次捕获，正则表达式**依然需要加全局修饰符g**，**不加g也只捕获第一个**】
```
	var str='zhufeng2017peixun2018yangfan2019qihang2020zhidao9999';
    var reg=/\d+/;
    console.log(str.match(reg));//->["2017", index:0,...]

```

- 在内置类正则的原型上扩展一个myExecAll方法，来实现执行一次捕获多次的效果 -----> 【用match方法捕获的原理】 
```
    RegExp.prototype.myExecAll=function myExecAll() {
        var str=arguments[0]||''; 
        

		//->如果第一个参数值没有传递的话，我们让其默认值为空字符串
 /*     if (typeof arguments[0] === 'undefined') {
            str='';
        }                   */

        //正则只有加g，才能捕获全部，没有加的话我们只让其捕获第一个即可 => 需要判断有没有加g  如果没有加就执行一次 reg.exec(str)  加了就进行循环
        // => 如果reg.global-> true 表明加了g ；如果reg.global-> false 表明没有加g


        if(!this.global) return this.exec(str);
        
        //->如果reg.global是false 就执行return 后面的语句 ； 如果reg.global是true 就执行if下一行的语句 --> 即执行while循环来实现捕获


        var ary=[],
            result=this.exec(str);
        while (result) { 
           ary.push(result[0]);
           result=this.exec(str);
        };//如果result为true 即不为null 就执行循环体
        
        return ary.length ===0 ? null : ary;

        //->如果数组长度是0，就返回null；如果长度不为0，就返回这个数组ary
        
    };
//    reg.myExecAll(str);//->用的时候直接调用方法myExecAll



// 无注释版：
	RegExp.prototype.myExecAll=function myExecAll() {
    var str=arguments[0]||'';
    if(!this.global) return this.exec(str);
    var ary=[],
        result=this.exec(str);
    while (result) { 
        ary.push(result[0]);
        result=this.exec(str);
    }
    return ary.length ===0 ? null : ary;
};

```

- `replace` ----- 字符串里的方法(实现字符串的替换) ，在不使用正则的情况下，每执行一次只能替换一次，执行多次的时候每一次都是从头开始查找替换
	- 如果**第一项传递的参数是正则**表达式的话，**浏览器默认的**也**会和我们的字符串进行捕获**
		- 而且**每捕获一次**就会**触发**后面的回调**函数执行一次**
		- 每一次执行匿名函数都默认给函数传递了一些参数值：arguments ，把正则捕获的内容获取到
	- **第二个参数**换成一个**匿名函数**
		- 匿名函数执行多少次，取决于正则能在字符串中捕获多少次 
		- 每一次执行匿名函数，里面传递的参数值arguments和我们自己通过exec捕获到的结果是非常类似的(即使正则有分组，同样可以通过arguments获取到分组捕获的内容)
		-  return ： 你返回的结果是什么 ，就相当于把当前 这一次大正则捕获的内容替换成你返回的内容

```
    var str='zhufeng2017peixun2018yangfan2019qihang2020zhidao9999';
    var reg=/(\d)+/g;
    //->借用字符串的replace方法(实现字符串的替换)，如果第一项传递的是正则的话，浏览器默认的也会和我们的字符串进行捕获，而且每捕获一次就会触发后面的回调函数执行一次(大部分支持正则的字符串方法，基本上都有这个特点，例如：split...)
    console.log(reg.exec(str));//->["2017", "7", index: 7, input: "zhufeng2017peixun2018yangfan2019qihang2020zhidao9999"]
    str.replace(reg,function () {
        //->当前函数被执行了5次，因为reg和str相匹配的有五项，我们的正则会捕获五次
        //->每一次执行函数都默认给函数传递了一些参数值：arguments ， arguments存储的值和每一次通过exec捕获的结果一模一样(既有大正则捕获的结果，也有小分组捕获的结果)
        console.log(arguments);//->输出五次
        //-> 第一次执行匿名函数的结果 ["2017", "7", 7, "zhufeng2017peixun2018yangfan2019qihang2020zhidao9999"]
        //-> 第二次执行匿名函数的结果 ["2018", "8", 17, "zhufeng2017peixun2018yangfan2019qihang2020zhidao9999"]...
        console.log(arguments[0],arguments[1]);//-> 分别输出本次大正则和第一个小分组捕获的结果
        //-> 第一次执行匿名函数输出结果  2017 7
        //-> 第二次执行匿名函数输出结果  2018 8

        // return '@';//->在当前的函数中你返回的是什么，就相当于把本次正则匹配的结果替换成什么，如果不写return，就默认把正则捕获到的替换成undefined
    });
    console.log(str);

```

> replace第一项的值是正则的时候：
1. 首先我们和 exec捕获一样，把所有和我们正则匹配的都捕获到，然后把捕获的内容替换成我们需要替换的新内容
2. 按照正则把str中所有可以匹配的都捕获到，然后统一都替换成新内容



 > 【大部分**支持正则**的字符串方法，基本上都有这个特点，例如：split...】


> RegExp**.$1** ---- 获取第一个分组捕获的内容

###正则的懒惰性

比如exec()方法不管执行多少次，捕获到的永远是第一个 ==> 这就是正则的`懒惰性`
-  是**因为**正则里面有一个属性 **lastIndex**
	-  `reg.lastIndex` ： **下一次正则捕获的起始索引位置**(也就是下一次捕获的时候是从哪开始找的)
		-  第一次捕获的时候值为0，在**正则表达式不进行处理**的情况下，**下一次捕获之前这个值依然为0**，所以会重复捕获第一个内容
		-  而且即使我们手动把lastIndex的值改变了，也没有作用
```
	var str='zhufeng2017peixun2018';
    var reg=/\d+/;
	console.log(reg.lastIndex);//->0
    console.log(reg.exec(str));//->['2017'...]
    console.log(reg.lastIndex);//->0
    reg.lastIndex=11;
    console.log(reg.lastIndex);//->11
    console.log(reg.exec(str));//->['2017'...]
```
- `解决`正则的**懒惰性**只有一种办法：**给正则`加`全局修饰符`g`**(global)
```
//->加上g就可以解决了
    var str='zhufeng2017peixun2018';
    var reg=/\d+/g;
    console.log(reg.exec(str));//->['2017'...]
    console.log(reg.lastIndex);//->11
    console.log(reg.exec(str));//->['2018'...]
    console.log(reg.lastIndex);//->21
    console.log(reg.exec(str));//->null
```

###正则的贪婪性

- 正则捕获的贪婪性：每一次**捕获的结果**都是当前正则匹配的**最长结果**
	- 例如：2017符合 2也符合，但是捕获的是2017

- **`解决`**正则的**贪婪性**---- 如果想获取最小长度的结果
	- 在**量词元字符后**面 **`加 ?`**


###问号  ？ 在正则中的作用：

**五大作用：**
1. 放在一个普通的元字符后面，代表出现零到一次 ==> 仅仅是**一个量词元字符**
2. 放在一个量词元字符后面，代表**取消正则捕获**时候的**贪婪性**
3. **(?:)**  ----- 设定**当前分组只匹配不捕获**
4. **(?=)** ----- **正向预查** 【只匹配不捕获】
5. **(?!)**  ----- **负向预查** 【只匹配不捕获】
 